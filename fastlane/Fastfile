default_platform(:ios)

# Configuration for different environments
ENVIRONMENT_CONFIG = {
  'dev' => {
    app_identifier: "com.ciCdTestingZesium.dev",
    scheme: "GithubActions-Dev",
    configuration: "Debug",
    profile_name_prefix: "DevProfile"
  },
  'staging' => {
    app_identifier: "com.ciCdTestingZesium.staging",
    scheme: "GithubActions-Staging",
    configuration: "Release",
    profile_name_prefix: "StagingProfile"
  },
  'prod' => {
    app_identifier: "com.ciCdTestingZesium.app",
    scheme: "GithubActions",
    configuration: "Prod",
    profile_name_prefix: "ProdProfile"
  }
}

platform :ios do
  desc "Run tests including snapshots"
  lane :test do
    root_path = "/Users/runner/work/swift-githubactions/swift-githubactions"
    test_output_path = "#{root_path}/fastlane/test_output"
    xcresult_path = â€œ#{test_output_path}/MyFeature.xcresult"

# Print current path and contents before doing anything
    puts "Current directory: #{Dir.pwd}"
    sh("ls -R #{root_path}/sumer-ios/Tests")

    # Create test output directory
    FileUtils.mkdir_p(test_output_path)

    # Print directory structure before tests
    puts "Test output directory created at: #{test_output_path}"
    sh("ls -la #{test_output_path}")

    # Cleanup old reference images
    FileUtils.rm_rf("#{root_path}/sumer-ios/Tests/MyTestSupport/ReferenceImages")  # Updated path
    
    # Clone snapshot repository
    sh("git clone https://x-access-token:#{ENV['REPO_TOKEN']}@github.com/#{ENV['SNAPSHOT_REPO']}.git GitStorageForSnapshots")
    
    # Create directory for reference images with correct path
    FileUtils.mkdir_p("#{root_path}/sumer-ios/Tests/MyTestSupport/ReferenceImages")  # Updated path
    
    if Dir.exist?("GitStorageForSnapshots/ReferenceImages")
      puts "Found reference images in repository"
      # Copy with verbose flag to see what's being copied
      FileUtils.cp_r(Dir["GitStorageForSnapshots/ReferenceImages/."], "#{root_path}/sumer-ios/Tests/MyTestSupport/ReferenceImages/", verbose: true)
      
      # Verify the copied files
      puts "Contents of reference images directory after copy:"
      sh("ls -R #{root_path}/sumer-ios/Tests/MyTestSupport/ReferenceImages")
    end

    # Define devices to test (if you set multiple devices, you need to add them to main.yml file also in Set up required iOS Simulators part)
    # If we won't use multiple devices, we can remove this property and use device name value directly in scan method
    devices = [
      "iPhone SE (3rd generation)"
    ]

devices.each do |device|
      device_name = device.downcase.gsub(" ", "_").gsub("(", "").gsub(")", "")
      xcresult_path = "#{test_output_path}/MyFeature_#{device_name}.xcresult"

      scan(
        package_path: "#{root_path}/sumer-ios",
        scheme: "MyFeature",
        device: device,
        clean: true,
        configuration: "Debug",
        derived_data_path: "#{root_path}/DerivedData",
        output_style: 'raw',
        output_types: 'raw,html,junit',
        result_bundle: true,
        result_bundle_path: xcresult_path,
        buildlog_path: test_output_path,
        include_simulator_logs: true,
        xcargs: "CI=true ENABLE_TESTABILITY=YES ONLY_ACTIVE_ARCH=YES"
      )
    end
  end


  desc "Build and upload to TestFlight"
  lane :beta do |options|
    environment = options[:environment] || 'dev'
    config = ENVIRONMENT_CONFIG[environment]
    
    UI.message("ðŸš€ Deploying to #{environment} environment")
    
    api_key_path = File.join(Dir.pwd, "AuthKey.p8")
    profile_path = File.join(Dir.pwd, "#{config[:profile_name_prefix]}.mobileprovision")
    
    begin
      # Decode and save API key and provisioning profile
      File.write(api_key_path, Base64.decode64(ENV["API_KEY_BASE64"]))
      File.write(profile_path, Base64.decode64(ENV["BUILD_PROVISION_PROFILE_BASE64"]))
      
      # Extract profile name using security cms
      profile_name = sh("security cms -D -i #{profile_path} | plutil -extract Name raw -o - -", log: false).strip
      UI.message("ðŸ“„ Provisioning profile name: #{profile_name}")
      
      # Install the provisioning profile
      profile_uuid = sh("security cms -D -i #{profile_path} | plutil -extract UUID raw -o - -", log: false).strip
      destination_path = File.expand_path("~/Library/MobileDevice/Provisioning Profiles/#{profile_uuid}.mobileprovision")
      
      FileUtils.mkdir_p(File.dirname(destination_path))
      FileUtils.cp(profile_path, destination_path)
      UI.message("ðŸ“² Installed provisioning profile to: #{destination_path}")
      
      app_store_connect_api_key(
        key_id: ENV["API_KEY"],
        issuer_id: ENV["ISSUER_ID"],
        key_filepath: api_key_path
      )

      current_build = latest_testflight_build_number(
        api_key: lane_context[SharedValues::APP_STORE_CONNECT_API_KEY],
        app_identifier: config[:app_identifier]
      )
      
      new_build_number = current_build + 1
      UI.message("ðŸ”¢ Current build: #{current_build}, new build will be: #{new_build_number}")
      
      increment_build_number(
        build_number: new_build_number,
        xcodeproj: "GithubActions.xcodeproj"
      )
      
      build_ios_app(
        project: "GithubActions.xcodeproj",
        scheme: config[:scheme],
        configuration: config[:configuration],
        export_method: "app-store",
        clean: true,
        skip_profile_detection: true,
        build_path: "build",
        archive_path: "build/archive",
        output_directory: "build",
        output_name: "LFM-GHactions-#{environment}.ipa",
        include_bitcode: false,
        include_symbols: false,
        export_options: {
          method: "app-store",
          provisioningProfiles: {
            config[:app_identifier] => profile_name
          },
          signingStyle: "manual"
        }
      )
      
      upload_to_testflight(
        skip_waiting_for_build_processing: true,
        ipa: "build/LFM-GHactions-#{environment}.ipa",
        api_key: lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
      )
    ensure
      # Clean up temporary files
      [api_key_path, profile_path].each do |file|
        File.delete(file) if File.exist?(file)
      end
    end
  end
end